/**
This object provides all the functions needed to interact with a management
landscape represented by a graph of MngUnits. The key functions are:
1- Build the management landscape
*/

import org.apache.spark._
import org.apache.spark.graphx._
import org.apache.spark.rdd.RDD
import org.apache.spark.graphx.Edge
import org.apache.spark.graphx.Graph

object MngLandscape{

  /**
  This function does a voronoi tesselation over the planning landscape to define
  the composition of the management units
  @param nm is the number of management units
  @param np is the number of planning units
  @return a map storing each management unit's composition and their ids
  * TODO: abstract voronoiTesselation torender it more flexible
  **/
  def buildNullCompMap(nm: Int,
                       np: Int): ParMap[Long, VertexRDD[VertexId]] = {
    VoronoiUtils.voronoiTesselation(nm,np).groupBy( _._2 ).map{ (key, val) => {
      key.toLong -> val.values
    }.toMap.par
  }

  /**
  This function takes a map generated by the voronoi tesselation and randomly
  associates to each unit a management strategy according to the porportion of
  sparing-sharing units for the simulation
  @param map is the map containing the composition of the management units
  @param fs is the fractions of land-sparing MngUnits
  @return a map storing each management unit with their Id
  */
  def buildStrategies(map: ParMap[Long, VertexRDD[VertexId]],
                      fs: Double): ParMap[Long,MngUnit] = {
    // this is the number of land sparing management units
    val ns: Int = (fs*map.size).toInt
    // get the Ids of the to be sparing units:
    // since they can be chosen with a uniform spatial distribution we can just
    // shuffle the indexes and grab the first ns ones
    val sparingIds: List[Int] = rnd.shuffle(map.keys).take(ns)
    // create a new map with the management units
    map.map{ (key,val) =>
      if sparingIds.contains(key) { key -> MngUnit(val,"Sparing") }
      else { key -> MngUnit(val,"Sharing") }
    }
  }

  /**
  @param nm is the number of management units
  @param np is the number of planning units
  @param fs is the fraction of land-sparing management units
  @return the composition graph of the management landscape
  */
  def build(nm: Int,
            np: Int,
            fs: Double): Graph[MngUnit, Long] = {

    val nullmap = buildNullCompMap(nm,np)
    val compmap = buildStrategies(nullmap,fs)

    val sc: SparkContext
    // the units are defined by a vertex id which is the id of the MngUnit
    // and a VertexRDD of VertexIds from to the Planning composition graph
    // and representing the PlanningUnits belonging to the MngUnit.
    val units: RDD[(VertexId, MngUnit)] =
      sc.parallelize( compmap.map{ (_._1, _._2) }.toSeq )

    // for the time being there are no connections between Management Units
    val edges: RDD[Edge[Long]] =
      sc.parallelize(Seq())
    Graph(units,edges)
  }

  /**
  @param mng the management landscape composition
  @param pln the planning landscape
  @param eco the biophyisical landscape
  @return an RDD with the relative conversion probabilities at each management unit. We assume uniform probability among the available units
  */
  def probabilities(mng: Graph[MngUnit, Long],
                    pln: Graph[PlanningUnit, Long],
                    eco: Graph[EcoUnit, Long]): VertexRDD[Double] = {
    val sg: Graph[MngUnit, Long] = mng.subgraph(vpred = (vid,mu) => mu.isAvailable(pln,eco))
    sg.vertices.mapValues(_ / sg.count)
  }

  /**
  @param ival is the initial value for the propensities
  @param tcp is the total conversion propensity
  @return a ListMap containing the choosing cummulative propensity for each management unit
  */
  def propensities(ival: Double,
                   tcp: Double,
                   mng: Graph[MngUnit, Long],
                   pln: Graph[PlanningUnit, Long],
                   eco: Graph[EcoUnit, Long]): ListMap[VertexId,Double] = {
    val prop: ListMap[VertexId,Double] = ListMap(probabilities(mng,pln,eco).mapValues(_ * tcp).collect.toSeq.sortWith(_._1 < _._1):_*)
    prop.scanLeft((-1L,ival))( (pre, k -> v) => k -> v + pre._2 )
  }

}
